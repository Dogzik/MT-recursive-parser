# MT-recursive-parser

Рассмотрим грамматику для арифметических выражений со сложением, вычитанием и унарными плюсом и минусом:
```
E -> E+T
E -> E-T
E -> T
T -> T*F
T -> F
F -> -F
F -> +F
F -> n
F -> (E)
```
* E - арифметическое выражение
* Т - обобщённое слагаемое
* F - обобщённый множитель

Заметим, что в все операции в ней имеют левую ассоциативность, что собенно важно для `-`. Устраним левую рекурсию и правое ветвление:
```
E -> TX
X -> +TX
X -> -TX
X -> ε
T -> FY
Y -> *FY
Y -> ε
F -> -F
F -> +F
F -> n
F -> (E)
```

Старые символы сохранили свой смысл и добавилась пара новых:

* `X` - суффикс(возможно пустой) из слагаемых вида `T`
* `Y` - суффикс(возможно пустой) из множителей вида `F`


Построим для этой грамматики множества **FIRST** и **FOLLOW**:

| Нетерминал | FIRST             | FOLLOW              |
| ---------- |------------------ | ------------------- |
| `E`        | `(` `-` `+` `n`   | `$` `)`             |
| `X`        | `ε` `+` `-`       | `$` `)`             |
| `T`        | `(` `-` `+` `n`   | `$` `)` `+` `-`     |
| `Y`        | `ε` `*`           | `$` `)` `+` `-`     |
| `F`        | `(` `-` `+` `n`   | `$` `)` `+` `-` `*` |

Заметим, что выполняются условия теоремы связывающие **LL(1)** грамматики с множествами **FIRST** и **FOLLOW**, а значит можно написать нисходящий парсер.
