# MT-recursive-parser

Рассмотрим грамматику для арифметических выражений со сложением, вычитанием и унарным минусом:
```
E -> E+T
E -> E-T
E -> T
T -> T*F
T -> F
F -> -F
F -> n
F -> (E)
```
* E - арифметическое выражение
* Т - обобщённое слагаемое
* F - обобщённый множитель

Заметим, что в все операции в ней имеют левую ассоциативность, что собенно важно для `-`. Устраним левую рекурсию и правое ветвление:
```
E -> TX
X -> +TX
X -> -TX
X -> ε
T -> FY
Y -> *FY
Y -> ε
F -> -F
F -> n
F -> (E)
```

Старые символы сохранили свой смысл и добавилась пара новых:

* `X` - суффикс(возможно пустой) из слагаемых вида `T`
* `Y` - суффикс(возможно пустой) из множителей вида `F`

Казалось бы всё хорошо. Ведь такая грамматика лежит в классе **LL(1)**. Однако если написать нисходящий парсер для неё, то обнаружится интерсный артефакт: выражение `(1 + 2))` будет успешно разобрано. А именно разборщик вернёт корретное дерево соотвествующее префиксу `(1 + 2)`. Это просиходит из-за того, что нетерминал `X` не различает находится ли он внутри скобок или нет, а просто раскрывается в `ε` и отдаёт управелние вверх по рекурсии, увидя `)` или конец строки. Для этого нужно на уровне грамматики понимать находимся ли мы внутри скобок или нет. Заведём для этого просто копии наших состояний, а последнее правило исходной грамматики будет раскрываться не в `E`, а его копию `I`(от слова Insisde). Это и будет означать вложенность в скобки. 

```
E -> TX
X -> +TX
X -> -TX
X -> ε
T -> FY
Y -> *FY
Y -> ε
F -> -F
F -> n
F -> (I)
I -> HA
A -> +HA
A -> -HA
A -> ε
H -> KB
B -> *KB
B -> ε
K -> -K
K -> n
K -> (I)
```



Построим для этой грамматики множества **FIRST** и **FOLLOW**:

| Нетерминал | FIRST       | FOLLOW          |
| ---------- |------------ | ----------------|
| `E`        | `(` `-` `n` | `$`             |
| `X`        | `ε` `+` `-` | `$`             |
| `T`        | `(` `-` `n` | `$` `+` `-`     |
| `Y`        | `ε` `*`     | `$` `+` `-`     |
| `F`        | `(` `-` `n` | `$` `*` `+` `-` |
| `I`        | `(` `-` `n` | `)`             |
| `A`        | `ε` `+` `-` | `)`             |
| `H`        | `(` `-` `n` | `)` `+` `-`     |
| `B`        | `ε` `*`     | `)` `+` `-`     |
| `K`        | `(` `-` `n` | `)` `*` `+` `-` |


Заметим, что так же выполняются условия теоремы связывающие **LL(1)** грамматики с множествами **FIRST** и **FOLLOW**, а значит можно написать нисходящий парсер.
